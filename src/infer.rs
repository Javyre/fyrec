use crate::ast::*;
use crate::graph::*;
use crate::parser::{format_at_pos, Path};
use enum_dispatch::enum_dispatch;
use yansi::Paint;

use std::rc::Rc;
use std::fmt;
use std::cell::RefCell;

use indexmap::{IndexMap, IndexSet, indexmap, indexset};
use anyhow::{Context, Result, Error, bail};
use derive_more::{ Display, DebugCustom };

impl<'a> Expr<'a> {
    fn get_fun_calls(&self) -> IndexSet<&Rc<Path<'a>>> {
        match self {
            Expr::FunCal(fc) => indexset![&fc.name.path],
            Expr::If(i) => {
                let mut r: IndexSet<&Rc<Path>>
                    = i.clauses.iter().flat_map(|(c, e)| {
                        let mut r = c.get_fun_calls();
                        r.extend(e.get_fun_calls());
                        r
                    }).collect();
                if let Some(otherwise) = &i.otherwise {
                    r.extend(otherwise.get_fun_calls().into_iter());
                }
                r
            },
            Expr::Block(bl) => {
                let mut r: IndexSet<&Rc<Path>>
                    = bl.body.iter().flat_map(|s| match s {
                    Stmt::Expr(e) => e.get_fun_calls(),
                    Stmt::VarLet(vl) => vl.val.get_fun_calls(),
                }).collect();
                if let Some(ret) = &bl.ret {
                    r.extend(ret.get_fun_calls().into_iter());
                }
                r
            },
            _ => indexset![],
        }
    }
}

impl<'a> IGraphNode<Rc<Path<'a>>> for Rc<FunDef<'a>> {
    fn get_id(&self) -> Rc<Path<'a>> {
        Rc::clone(&self.name.path)
    }
    fn get_deps(&self) -> IndexSet<&Rc<Path<'a>>> {
        self.body.get_fun_calls()
    }
}

impl<'a> IGraphCtx<Rc<Path<'a>>, Rc<FunDef<'a>>, Error> for Symbols<'a> {
    fn get_node(&self, id: &Rc<Path<'a>>) -> Result<&Rc<FunDef<'a>>> {
        self.fundefs.get(id)
            .with_context(|| format!("`{}' is not a function", id))
    }
}

#[derive(Debug, Display, Clone, Copy, PartialEq, Eq, Hash)]
#[display(fmt = "T{}", "self.0")]
pub struct TypeVar(usize);

#[derive(Clone, Debug, PartialEq, Eq, Display)]
pub enum TypeIdent<'a> {
    #[display(fmt = "{}", _0)]
    User(Rc<Path<'a>>),

    #[display(fmt = "FUN")]
    Function,

    #[display(fmt = "INT")]
    Integer,

    #[display(fmt = "STR")]
    String,

    #[display(fmt = "BOO")]
    Boolean,

    #[display(fmt = "NIL")]
    Unit,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Display)]
pub enum RowIndex<'a> {
    #[display(fmt = "{}", _0)]
    Label(&'a str),
    #[display(fmt = "{}", _0)]
    Index(usize),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Type<'a> {
    // TODO: rename Concrete to more proper name (scalar?)
    Concrete(TypeIdent<'a>, Vec<Type<'a>>),

    // Row-polymorphic type (implicitly growing)
    Row(IndexMap<RowIndex<'a>, Type<'a>>),

    // Concrete row type corresponding to a struct (cannot grow)
    Record(TypeIdent<'a>, IndexMap<RowIndex<'a>, Type<'a>>),

    Scheme(Vec<TypeVar>, Box<Type<'a>>),

    Variable(TypeVar),
}

macro_rules! Type {
    (@impl $id:expr, $args:expr) => (Type::Concrete($id, $args));
    ($builtin:ident ( ...$args:expr )) => (
        Type!(@impl TypeIdent::$builtin, $args)
    );
    ($builtin:ident ( $($args:expr),* )) => (
        Type!(@impl TypeIdent::$builtin, vec![$($args.into()),*])
    );
    ([$typeid:expr] ( ...$args:expr )) => (
        Type!(@impl $typeid, $args)
    );
    ([$typeid:expr] ( $($args:expr),* )) => (
        Type!(@impl $typeid, vec![$($args.into()),*])
    );
}


#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SubstID(pub usize);

// TODO: make TaggedSubstitutionSet and SubstitutionSet distinct
#[derive(Debug, Clone)]
pub struct SubstitutionSet<'a> {
    pub subst: IndexMap<TypeVar, Type<'a>>,

    // NOTE: to avoid substituting shared types more than once in the
    // same substitution pass, a new substitution id is generated by
    // the infercontext when a new pass is started.
    pub id: SubstID,
}

#[derive(Debug, Clone)]
struct IfConstraintCtx<'a> {
    if_ty: Type<'a>,
    clause_ty: Type<'a>,
    last_subst_id: Option<SubstID>,
}

#[derive(Debug, Clone)]
struct IfCondConstraintCtx<'a> {
    cond_ty: Type<'a>,
    last_subst_id: Option<SubstID>,
}

#[derive(Debug, Clone)]
struct FunCalConstraintCtx<'a> {
    fun: Rc<Path<'a>>,
    funty: Type<'a>,
    calling_funty: Type<'a>,
    last_subst_id: Option<SubstID>,
}

#[derive(Debug, Clone)]
struct StructLitFieldConstraintCtx<'a> {
    field: RowIndex<'a>,
    field_ty: Type<'a>,
    expr_ty: Type<'a>,
    struct_name: Rc<Path<'a>>,
    last_subst_id: Option<SubstID>,
}

// TODO: lift last_subst_id to ConstraintCtx directly
#[derive(Debug, Clone)]
pub enum ConstraintCtx<'a> {
    If {
        if_: Rc<RefCell<IfConstraintCtx<'a>>>
    },
    IfCond {
        if_cond: Rc<RefCell<IfCondConstraintCtx<'a>>>
    },
    FunCal {
        fun_cal: Rc<RefCell<FunCalConstraintCtx<'a>>>
    },
    FunCalArg {
        fun_cal: Rc<RefCell<FunCalConstraintCtx<'a>>>,
        n: usize,
    },
    StructLitField {
        struct_field: Rc<RefCell<StructLitFieldConstraintCtx<'a>>>,
    },
}

impl<'a> ConstraintCtx<'a> {
    fn context(&self) -> String {
        match self {
            ConstraintCtx::If{ if_ } => {
                let IfConstraintCtx{ if_ty, clause_ty, .. } = &*if_.borrow();

                format!("in if statement. All if clauses should be the same type.
expected: {}\n     got: {}", if_ty, clause_ty)
            },
            ConstraintCtx::IfCond { if_cond } => {
                let IfCondConstraintCtx{ cond_ty, .. } = &*if_cond.borrow();

                format!("in if statement. If conditions should be boolean expressions.
expected: {}\n     got: {}", Type!(Boolean()), cond_ty)
            },
            ConstraintCtx::FunCal{ fun_cal: fc } => {
                let FunCalConstraintCtx{ fun, funty, calling_funty, .. } = &*fc.borrow();

                match (&funty, &calling_funty) {
                    (Type::Concrete(_, aargs), Type::Concrete(_, bargs))
                        if aargs.len() != bargs.len() => {
                            format!("in call to {}. Wrong argument count.
expected: {} arguments\n     got: {} arguments",
                                    fun, aargs.len()-1, bargs.len()-1)
                        }
                    _ =>
                        format!("in call to {}\nexpected: {}\n     got: {}",
                                fun, funty, calling_funty)
                }
            },
            ConstraintCtx::FunCalArg{ n, fun_cal: fc } => {
                let n = *n;
                let FunCalConstraintCtx{ fun, funty, calling_funty, .. } = &*fc.borrow();
                let (funty_args, calling_funty_args) = {
                    if let (Type::Concrete(TypeIdent::Function, funty_args),
                            Type::Concrete(TypeIdent::Function, calling_funty_args))
                        = (funty, calling_funty) {
                            (funty_args, calling_funty_args)
                        } else {
                            unreachable!();
                        }
                };

                assert_eq!(funty_args.len(), calling_funty_args.len());

                if n == funty_args.len()-1 {
                    format!("in return value of call to {}\nexpected: {}\n     got: {}",
                            fun, calling_funty_args[n], funty_args[n])
                } else {
                    format!("in param {} in call to {}\nexpected: {}\n     got: {}",
                            n+1, fun, funty_args[n], calling_funty_args[n])
                }
            },
            ConstraintCtx::StructLitField{ struct_field: sf } => {
                let sf = sf.borrow();
                format!("in field {} of struct {}\nexpected: {}\n     got: {}",
                        sf.field, sf.struct_name, sf.field_ty, sf.expr_ty)
            },
        }
    }

    fn substitute(&self, subst: &SubstitutionSet<'a>) {
        match self {
            ConstraintCtx::If { if_ } => {
                if if_.borrow().last_subst_id != Some(subst.id) {
                    let mut refmut = if_.borrow_mut();
                    refmut.if_ty.substitute(subst);
                    refmut.clause_ty.substitute(subst);
                    refmut.last_subst_id = Some(subst.id);
                }
            },
            ConstraintCtx::IfCond { if_cond } => {
                if if_cond.borrow().last_subst_id != Some(subst.id) {
                    let mut refmut = if_cond.borrow_mut();
                    refmut.cond_ty.substitute(subst);
                    refmut.last_subst_id = Some(subst.id);
                }
            },
            ConstraintCtx::FunCal { fun_cal: fc, .. }
            | ConstraintCtx::FunCalArg { fun_cal: fc, .. }
            => {
                if fc.borrow().last_subst_id != Some(subst.id) {
                    let mut refmut = fc.borrow_mut();
                    refmut.funty.substitute(subst);
                    refmut.calling_funty.substitute(subst);
                    refmut.last_subst_id = Some(subst.id);
                }
            },
            ConstraintCtx::StructLitField { struct_field: sf } => {
                if sf.borrow().last_subst_id != Some(subst.id) {
                    let mut refmut = sf.borrow_mut();
                    refmut.field_ty.substitute(subst);
                    refmut.expr_ty.substitute(subst);
                    refmut.last_subst_id = Some(subst.id);
                }
            }
        }
    }
}

#[derive(Debug, Clone)]
pub enum Constraint<'a> {
    Eq {
        a: Type<'a>,
        b: Type<'a>,
        span: Span<'a>,
        ctx: Option<Rc<ConstraintCtx<'a>>>,
    },
}

impl<'a> Type<'a> {
    fn free_vars_impl(&self, set: &mut IndexSet<TypeVar>) {
        match self {
            Self::Concrete(_id, args) => {
                for arg in args {
                    arg.free_vars_impl(set);
                }
            },
            // NOTE: assuming schemes are created always with fresh quantifier
            // variables; meaning that quantifier vars cannot possibly be
            // previously existing outside of the scheme type body.
            Self::Scheme(quant, ty) => {
                ty.free_vars_impl(set);
                for q in quant {
                    set.remove(q);
                }
            },
            Self::Variable(tv) => { set.insert(*tv); },

            Self::Row(columns) |
            Self::Record(_, columns) => {
                for (_, ty) in columns {
                    ty.free_vars_impl(set);
                }
            },
        }
    }

    pub fn free_vars(&self) -> IndexSet<TypeVar> {
        let mut r = IndexSet::with_capacity(10);
        self.free_vars_impl(&mut r);
        r
    }

    pub fn substitute(&mut self, subst: &SubstitutionSet<'a>) {
        match self {
            Self::Concrete(_, args) => {
                args.iter_mut().for_each(|a| a.substitute(subst));
            },

            // NOTE: naively ignore quantifier and substitute body as if
            // monotype.
            Self::Scheme(_, ty) => {
                ty.substitute(subst);
            },

            Self::Variable(tv) => if let Some(ty) = subst.subst.get(tv) {
                *self = ty.clone();
            },

            Self::Row(columns) |
            Self::Record(_, columns) => {
                columns.iter_mut().for_each(|(_, ty)| ty.substitute(subst));
            },
        };
    }

    fn generalize(&self, gen: &mut impl TvarGen) -> Self {
        let free_vars = self.free_vars();
        // let mut quant = Vec::with_capacity(free_vars.len());

        // let subst = free_vars.into_iter().map(|ftv| (ftv, {
        //     let tv = gen.fresh_tvar();
        //     quant.push(tv);
        //     Self::Variable(tv)
        // })).collect();

        // Self::Scheme(quant, Box::new(self.substitute(&subst)))

        Self::Scheme(free_vars.into_iter().collect(),
                     Box::new(self.clone()))
    }

    fn instantiate(&self, gen: &mut InferContext<'a>, span: &Span<'a>)
        -> Result<Self> {
        if let Self::Scheme(quant, ty) = self {
            let subst = quant.iter().map(|q|
                (*q, Self::Variable(gen.fresh_tvar()))).collect();
            let subst = SubstitutionSet{
                subst, id: gen.fresh_subst_id(),
            };

            let mut ty: Type<'a> = *ty.clone();
            ty.substitute(&subst);
            Ok(ty)
        } else {
            let msg = span.format_err_at_pos(
                &format!("Attempt to instantiate non-scheme type: {}", self),
                true,
            ).unwrap();
            bail!("{}", msg);
        }
    }
}

impl<'a> fmt::Display for Type<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Type::Concrete(id, args) => {
                write!(f, "{}", id)?;

                if args.len() == 0 {
                    return Ok(());
                }

                write!(f, "(")?;
                for (i, a) in args.iter().enumerate() {
                    write!(f, "{}", a)?;
                    if i < args.len() - 1 {
                        write!(f, ", ")?;
                    }
                }
                write!(f, ")")
            }
            Type::Scheme(params, body) => {
                write!(f, "[forall ")?;
                for (i, p) in params.iter().enumerate() {
                    write!(f, "{}", p)?;
                    if i < params.len() - 1 {
                        write!(f, ", ")?;
                    }
                }
                write!(f, "].{}", body)
            },
            Type::Variable(tv) => write!(f, "{}", tv),

            Type::Row(columns) => {
                write!(f, "{{")?;
                for (i, (n, ty)) in columns.iter().enumerate() {
                    write!(f, "{}: {}", n, ty)?;
                    if i < columns.len() - 1 {
                        write!(f, ", ")?;
                    }
                }
                write!(f, "}}")
            },

            Type::Record(name, columns) => {
                let braces = if let Some((RowIndex::Label(..), _)) = columns.get_index(0) {
                    ('{', '}')
                } else {
                    ('(', ')')
                };
                write!(f, "{}{}", name, braces.0)?;
                for (i, (n, ty)) in columns.iter().enumerate() {
                    if braces.0 == '{' {
                        write!(f, "{}: {}", n, ty)?;
                    } else {
                        write!(f, "{}", ty)?;
                    }
                    if i < columns.len() - 1 {
                        write!(f, ", ")?;
                    }
                }
                write!(f, "{}", braces.1)
            },
        }
    }
}

impl<'a> fmt::Display for Constraint<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Constraint::Eq { a, b, .. } =>
                write!(f, "eq: {} = {}", a, b),
        }
    }
}

impl<'a> Constraint<'a> {
    fn new_eq(
        tya: Type<'a>,
        tyb: Type<'a>,
        span: Span<'a>,
        ctx: Option<Rc<ConstraintCtx<'a>>>,
    ) -> Self {
        Self::Eq {
            a: tya,
            b: tyb,
            ctx,
            span,
        }
    }

    pub fn span(&self) -> &Span<'a> {
        match self {
            Self::Eq { span, .. } => span,
        }
    }

    fn substitute(&mut self, subst: &SubstitutionSet<'a>) {
        match self {
            Self::Eq { a, b, ctx, .. } => {
                a.substitute(subst);
                b.substitute(subst);
                ctx.as_ref().map(|ctx|ctx.substitute(subst));
            },
        };
    }
}

pub trait TvarGen {
    fn fresh_tvar(&mut self) -> TypeVar;
}
#[derive(DebugCustom)]
#[debug(fmt = "TvarGenerator({})", next_var_id)]
pub struct TvarGenerator {
    next_var_id: usize,
}
impl TvarGen for TvarGenerator {
    fn fresh_tvar(&mut self) -> TypeVar {
        let r = self.next_var_id;
        self.next_var_id += 1;
        TypeVar(r)
    }
}
impl TvarGenerator {
    pub fn new() -> Self {
        Self { next_var_id: 0 }
    }
}

#[derive(DebugCustom)]
#[debug(fmt = "InferContext({:?}, {}, <ast_types>, <errors>)",
        tvar_gen, next_subst_id)]
struct InferContext<'a> {
    tvar_gen: TvarGenerator,
    next_subst_id: usize,
    ast_types: Vec<(AstNodeID, (Type<'a>, Span<'a>))>,
    errors: IndexSet<String>,
    symbols: &'a Symbols<'a>,
}

impl<'a> TvarGen for InferContext<'a> {
    fn fresh_tvar(&mut self) -> TypeVar {
        self.tvar_gen.fresh_tvar()
    }
}

impl<'a> InferContext<'a> {
    fn new(symbols: &'a Symbols<'a>, tvs: TvarGenerator) -> Self {
        Self {
            tvar_gen: tvs,
            next_subst_id: 0,
            ast_types: Vec::with_capacity(100),
            errors: IndexSet::new(),
            symbols,
        }
    }

    fn fresh_subst_id(&mut self) -> SubstID {
        let r = self.next_subst_id;
        self.next_subst_id += 1;
        SubstID(r)
    }

    fn bind_ast_type(&mut self, id: AstNodeID, ty: (Type<'a>, Span<'a>)) {
        self.ast_types.push((id, ty));
    }

    fn substitute_ast_types(&mut self, subst: &SubstitutionSet<'a>) {
        self.ast_types.iter_mut().for_each(|(_id, (ty, _span))| ty.substitute(&subst));
    }
}

impl<'a> Into<Type<'a>> for TypeVar {
    fn into(self) -> Type<'a> {
        Type::Variable(self)
    }
}


// NOTE: Thanks to `Path<'a>`s, there's no real need for scoping in the
// inference code. The purpose of Scope here is mainly to optimize memory usage
// as it is better than having one huge IndexMap which would end up containing
// all the symbols in the program.
struct Scope<'a> {
    frame_sizes: Vec<usize>,
    bindings: IndexMap<Rc<Path<'a>>, Type<'a>>,
}

impl<'a> Scope<'a> {
    fn new() -> Self {
        Self {
            frame_sizes: {
                let mut fss = Vec::with_capacity(10);
                fss.push(0);
                fss
            },
            bindings: IndexMap::with_capacity(50),
        }
    }

    fn push_frame(&mut self) {
        self.frame_sizes.push(0);
    }

    fn pop_frame(&mut self) {
        assert!(self.frame_sizes.len() > 1);

        for _ in 0..self.frame_sizes.pop().unwrap() {
            self.bindings.pop();
        }
    }

    fn get<'b>(&'b self, id: &Ident<'a>) -> Option<&Type<'a>> {
        self.bindings.get(&id.path)
    }

    fn try_get<'b>(&'b self, id: &Ident<'a>) -> Result<&Type<'a>> {
        self.get(id).with_context(|| {
            id.span
                .format_err_at_pos(
                    &format!("`{}` not found in scope", id.path), true)
                .unwrap()
        })
    }

    fn bind(&mut self, path: Rc<Path<'a>>, ty: Type<'a>) {
        if let Some(fs) = self.frame_sizes.last_mut() {
            *fs += 1;
        } else {
            unreachable!();
        }
        if let Some(_) = self.bindings.insert(path, ty) {
            panic!("{}\n{}",
                   "attempt to bind already existing path.",
                   "(this should not happend as paths should be unique)");
        }
    }

    fn substitute(&mut self, subst: &SubstitutionSet<'a>) {
        for (_, ty) in self.bindings.iter_mut() {
            ty.substitute(subst);
        }
    }
}

macro_rules! with_subscope {
    ($scp:ident => $subscp:ident { $($body:tt)* }) => {
        let $subscp = $scp;
        $subscp.push_frame();

        $($body)*

        $subscp.pop_frame();
        let $scp = $subscp;
    }
}

macro_rules! Constraint {
    (eq: $a:expr, $b:expr, $s:expr) => {
        Constraint::new_eq($a.into(), $b.into(), $s, None)
    };
    (eq: $a:expr, $b:expr, $s:expr, $c:expr) => {
        Constraint::new_eq($a.into(), $b.into(), $s, $c)
    };
}

#[enum_dispatch(Expr)]
trait GenConstraints<'a> {
    fn gen_constraints(
        &self,
        targ: TypeVar,
        cons: &mut Vec<Constraint<'a>>,
        ctx: &mut InferContext<'a>,
        scp: &mut Scope<'a>,
    ) -> Result<()>;
}

macro_rules! GenConstraints {
    (@type $ty:path,   ) => ($ty);
    (@type $ty:path, Rc) => (Rc<$ty>);
    (for $o:ident(
            $this:pat,
            $targ:ident,
            $cons:ident,
            $ctx:ident,
            $scp:ident
            )$(: $ty:ident)?  = $body:expr) => (
        impl<'a> GenConstraints<'a>
        for GenConstraints!(@type $o<'a>, $($ty)?) {
            fn gen_constraints(
                &self,
                $targ: TypeVar,
                $cons: &mut Vec<Constraint<'a>>,
                $ctx: &mut InferContext<'a>,
                $scp: &mut Scope<'a>,
            ) -> Result<()> {
                let $this = self;
                $body
            }
        }
    );

//     {Rc<$ty:ident<$lt:lifetime>>(&$self:ident, $targ:ident, $cons:ident, $ctx:ident, $scp:ident)
//      => $ret:expr} => {
//         impl<$lt> GenConstraints<$lt> for Rc<$ty<$lt>> {
//             fn gen_constraints<'s>(
//                 &self,
//                 $targ: TypeVar,
//                 $cons: &mut Vec<Constraint<$lt>>,
//                 $ctx: &mut InferContext,
//                 $scp: &Scope<$lt, 's>,
//             ) -> Result<()> {
//                 // self is not a valid identifier to pass a macro
//                 let $self = self;
//                 $ret
//             }
//         }
//     };
//     {$ty:ident<$lt:lifetime>(&$self:ident, $targ:ident, $cons:ident, $ctx:ident, $scp:ident)
//      => $ret:expr} => {
//         impl<$lt> GenConstraints<$lt> for $ty<$lt> {
//             fn gen_constraints<'s>(
//                 &self,
//                 $targ: TypeVar,
//                 $cons: &mut Vec<Constraint<$lt>>,
//                 $ctx: &mut InferContext,
//                 $scp: &Scope<$lt, 's>,
//             ) -> Result<()> {
//                 // self is not a valid identifier to pass a macro
//                 let $self = self;
//                 $ret
//             }
//         }
//     }
}

GenConstraints!(for Ident(_this, _targ, _cons, _ctx, _scp) = unimplemented!());
GenConstraints!(for Stmt(_this, _targ, _cons, _ctx, _scp) = unimplemented!());

GenConstraints!(for VarRef(this, targ, cons, ctx, scp) = {
    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));
    cons.push(
        Constraint!(
            eq: targ, scp.try_get(&this.name)?.clone(), this.span()));
    Ok(())
});

GenConstraints!(for IntLit(this, targ, cons, ctx, _scp) = {
    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));
    cons.push(Constraint!(eq: targ, Type!(Integer()), this.span()));
    Ok(())
});

GenConstraints!(for StrLit(this, targ, cons, ctx, _scp) = {
    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));
    cons.push(Constraint!(eq: targ, Type!(String()), this.span()));
    Ok(())
});

GenConstraints!(for BooLit(this, targ, cons, ctx, _scp) = {
    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));
    cons.push(Constraint!(eq: targ, Type!(Boolean()), this.span()));
    Ok(())
});

GenConstraints!(for StructLit(this, targ, cons, ctx, scp) = {
    let ty = ctx.symbols.types
        .get(&this.name.path)
        .context("getting type for struct")?
        .instantiate(ctx, &this.span())?;

    if let Type::Record(_, ty_map) = &ty {
        match &this.fields {
            StructLitFields::Named(exprs_map) => {
                for (name, (name_span, field)) in exprs_map {
                    let targ_ty = ty_map.get(&RowIndex::Label(name));
                    if let None = targ_ty {
                        let msg = name_span.format_err_at_pos(
                            "not a valid field of struct!",
                            true,
                        ).unwrap();
                        ctx.errors.insert(msg);
                    }
                }
                for (index, targ_ty) in ty_map {
                    let field_name = if let RowIndex::Label(name) = index {
                        name
                    } else {
                        let msg = this.span().format_err_at_pos(
                            "cannot construct tuple struct from named fields",
                            true,
                        ).unwrap();
                        ctx.errors.insert(msg);
                        continue;
                    };

                    let field = if let Some((_, field)) = exprs_map.get(field_name) {
                        field
                    } else {
                        let msg = this.span().format_err_at_pos(
                            &format!("missing field `{}` for struct litteral", field_name),
                            true,
                        ).unwrap();
                        ctx.errors.insert(msg);
                        continue;
                    };

                    let tv = ctx.fresh_tvar();

                    field.gen_constraints(tv, cons, ctx, scp)?;

                    let field_ctx = Rc::new(ConstraintCtx::StructLitField {
                        struct_field: Rc::new(RefCell::new(StructLitFieldConstraintCtx {
                            field: RowIndex::Label(field_name),
                            field_ty: targ_ty.clone(),
                            expr_ty: tv.into(),
                            struct_name: Rc::clone(&this.name.path),
                            last_subst_id: None,
                        }))
                    });

                    cons.push(Constraint!(eq: tv, targ_ty.clone(),
                                          field.span(), Some(field_ctx)));
                }
            },
            StructLitFields::UnNamed(exprs) => {
                if exprs.len() < ty_map.len() {
                    let msg = this.span().format_err_at_pos(
                        &format!("missing elements in tuple struct literal
expected: {} elements\n     got: {} elements", ty_map.len(), exprs.len()),
                        true,
                    ).unwrap();
                    ctx.errors.insert(msg);
                }

                for (i, e) in exprs.iter().enumerate() {
                    let targ_ty = ty_map.get(&RowIndex::Index(i));
                    let targ_ty = if let Some(targ_ty) = targ_ty {
                        targ_ty
                    } else {
                        let msg = e.span().format_err_at_pos(
                            &format!("excess elements in tupe struct literal
expected: {} elements\n     got: {} elements", ty_map.len(), exprs.len()),
                            true,
                        ).unwrap();
                        ctx.errors.insert(msg);
                        break;
                    };

                    let tv = ctx.fresh_tvar();

                    e.gen_constraints(tv, cons, ctx, scp)?;

                    let field_ctx = Rc::new(ConstraintCtx::StructLitField {
                        struct_field: Rc::new(RefCell::new(StructLitFieldConstraintCtx {
                            field: RowIndex::Index(i),
                            field_ty: targ_ty.clone(),
                            expr_ty: tv.into(),
                            struct_name: Rc::clone(&this.name.path),
                            last_subst_id: None,
                        }))
                    });

                    cons.push(Constraint!(eq: tv, targ_ty.clone(),
                                          e.span(), Some(field_ctx)));
                }
            },
        }
    } else {
        bail!("type of struct literal not a Record")
    }

    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));
    cons.push(Constraint!(eq: targ, ty, this.span()));
    Ok(())
});

GenConstraints!(for Block(this, targ, cons, ctx, scp) = {

    with_subscope!(scp => subscp {

        for stmt in &this.body {
            match stmt {
                Stmt::Expr(e) => {
                    e.gen_constraints(ctx.fresh_tvar(), cons, ctx, subscp)?;
                },
                Stmt::VarLet(vl) => {
                    let tvar = ctx.fresh_tvar();
                    vl.val.gen_constraints(tvar, cons, ctx, subscp)?;
                    subscp.bind(Rc::clone(&vl.var.path), tvar.into());
                },
            }
        }

        if let Some(ref e) = this.ret {
            e.gen_constraints(targ, cons, ctx, subscp)?;
        } else {
            cons.push(Constraint!(eq: targ, Type!(Unit()), this.span()));
        }
        ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));

    });

    Ok(())
});

GenConstraints!(for If(this, targ, cons, ctx, scp) = {
    let if_ty = if this.otherwise.is_some(){
        targ
    } else {
        cons.push(Constraint!(eq: targ, Type!(Unit()), this.span()));
        ctx.fresh_tvar()
    };

    for (cond, clause) in this.clauses.iter() {
        let cond_ty = ctx.fresh_tvar();
        let cond_ctx = Rc::new(ConstraintCtx::IfCond {
            if_cond: Rc::new(RefCell::new(IfCondConstraintCtx{
                cond_ty: cond_ty.into(),
                last_subst_id: None
            }))
        });
        cond.gen_constraints(cond_ty, cons, ctx, scp)?;
        cons.push(Constraint!(eq: cond_ty, Type!(Boolean()),
                              cond.span(), Some(cond_ctx)));

        let clause_ty = ctx.fresh_tvar();
        let clause_ctx = Rc::new(ConstraintCtx::If {
            if_: Rc::new(RefCell::new(IfConstraintCtx{
                if_ty: if_ty.into(),
                clause_ty: clause_ty.into(),
                last_subst_id: None
            }))
        });
        clause.gen_constraints(clause_ty, cons, ctx, scp)?;
        cons.push(Constraint!(eq: clause_ty, if_ty,
                              clause.span(), Some(clause_ctx)));
    }
    if let Some(clause) = this.otherwise.as_ref() {
        let clause_ty = ctx.fresh_tvar();
        let clause_ctx = Rc::new(ConstraintCtx::If {
            if_: Rc::new(RefCell::new(IfConstraintCtx{
                if_ty: if_ty.into(),
                clause_ty: clause_ty.into(),
                last_subst_id: None
            }))
        });
        clause.gen_constraints(clause_ty, cons, ctx, scp)?;
        cons.push(Constraint!(eq: clause_ty, if_ty,
                              clause.span(), Some(clause_ctx)));
    }

    Ok(())
});

GenConstraints!(for FunCal(this, targ, cons, ctx, scp) = {
    let mut fty_args = Vec::<Type<'a>>::with_capacity(this.args.len() + 1);
    for arg in &this.args {
        let tvar = ctx.fresh_tvar();
        fty_args.push(tvar.into());
        arg.gen_constraints(tvar, cons, ctx, scp)?;
    }
    fty_args.push(targ.into());

    let fty_b = Type!(Function(...fty_args));

    let fty_a = scp.try_get(&this.name)?;

    let fty_a = if let Type::Scheme(..) = fty_a {
        fty_a.instantiate(ctx, &this.span())?
    } else {
        fty_a.clone()
    };

    ctx.bind_ast_type(this.get_id(), (targ.into(), this.span()));

    let cons_ctx = ConstraintCtx::FunCal {
        fun_cal: Rc::new(RefCell::new(FunCalConstraintCtx{
            fun: Rc::clone(&this.name.path),
            funty: fty_a.clone(),
            calling_funty: fty_b.clone(),
            last_subst_id: None,
        }))
    };
    cons.push(Constraint!(eq: fty_a, fty_b,
                          this.span(), Some(Rc::new(cons_ctx))));

    Ok(())
});

impl<'a> FunDef<'a> {
    fn gen_constraints(
        self: &Rc<Self>,
        cons: &mut Vec<Constraint<'a>>,
        ctx: &mut InferContext<'a>,
        scp: &mut Scope<'a>,
    ) -> Result<Type<'a>> {

        with_subscope!(scp => subscp {

            let retty = ctx.fresh_tvar();

            let mut fty_args
                = Vec::<Type<'a>>::with_capacity(self.argnames.len() + 1);
            for name in &self.argnames {
                let tvar = ctx.fresh_tvar();
                fty_args.push(tvar.into());
                subscp.bind(Rc::clone(&name.path), tvar.into());
            }
            self.body.gen_constraints(retty, cons, ctx, subscp)?;
            fty_args.push(retty.into());
            let fty = Type!(Function(...fty_args));

        });

        Ok(fty)
    }
}

// group of recursive functions depending on eachother
struct FunDefGroup<'a, 'f>(Vec<&'f Rc<FunDef<'a>>>);
impl<'a, 'f> FunDefGroup<'a, 'f> {
    fn gen_constraints(
        &self,
        cons: &mut Vec<Constraint<'a>>,
        ctx: &mut InferContext<'a>,
        scp: &mut Scope<'a>,
    ) -> Result<()> {
        // TODO: detect situations that fall under limitations of type
        //       inference and output warnings telling user to
        //       explicitly type the function(s)

        with_subscope!(scp => subscp {

            for fundef in self.0.iter() {
                // monomorphic fun type within recursive function bodies
                subscp.bind(Rc::clone(&fundef.name.path),
                            ctx.fresh_tvar().into());
            }

            let mut ftys = Vec::with_capacity(self.0.len());
            for fundef in self.0.iter() {
                let fty = fundef.gen_constraints(cons, ctx, subscp)?;
                ftys.push(fty);
            }

            let subst = unify(cons, ctx);
            ctx.substitute_ast_types(&subst);
            substitute_constraints(cons, &subst);
            subscp.substitute(&subst);

            for (fundef, fty) in self.0.iter().zip(ftys.iter_mut()) {
                fty.substitute(&subst);
                let gen_fty = fty.generalize(ctx);

                let monoty = subscp.try_get(&fundef.name)?;
                let instance = gen_fty.instantiate(ctx, &fundef.span())?;
                cons.push(Constraint!(eq: monoty.clone(),
                                      instance, fundef.span()));
            }

            let subst = unify(cons, ctx);
            ctx.substitute_ast_types(&subst);
            substitute_constraints(cons, &subst);
            subscp.substitute(&subst);

            for (fundef, fty) in self.0.iter().zip(ftys.iter_mut()) {
                fty.substitute(&subst);
                *fty = fty.generalize(ctx);


                ctx.bind_ast_type(IAstNode::get_id(*fundef),
                                  (fty.clone(), fundef.span()));
            }

        });

        for (fundef, fty) in self.0.iter().zip(ftys.into_iter()) {
            scp.bind(Rc::clone(&fundef.name.path), fty);
        }

        Ok(())
    }
}

impl<'a> Module<'a> {
    pub fn gen_constraints(&self, symbols: &'a Symbols<'a>, tvs: TvarGenerator)
        -> Result<IndexMap<AstNodeID, (Type<'a>, Span<'a>)>> {

        let mut ctx = InferContext::new(symbols, tvs);
        let mut scp = Scope::new();
        let mut cons: Vec<Constraint<'a>> =
            Vec::with_capacity(self.toplvls.len() * 50);

        let fundefs = 
            topological_sort(symbols, &symbols.fundefs.values().collect())
            .context("Failed to order function dependencies")?;

        for group in fundefs.into_iter() {
            println!("rec-group:");
            for fd in group.iter() {
                println!("\t{} :\t{}", fd.name.path, fd.span().fragment());
            }
            FunDefGroup(group).gen_constraints(&mut cons, &mut ctx, &mut scp)?;
        }

        // TODO: inference on other ast toplvls (typedefs/structdefs)

        let subst = unify(&mut cons, &mut ctx);
        ctx.substitute_ast_types(&subst);
        // substitute_constraints(&mut cons, &subst);
        // scp.substitute(&subst);

        if ctx.errors.len() > 0 {
            bail!("{}", ctx.errors.into_iter().collect::<Vec<_>>().join("\n"));
        }

        let mut ast_types = IndexMap::with_capacity(ctx.ast_types.len());
        for (id, ty) in ctx.ast_types.into_iter() {
            if let Some(_) = ast_types.insert(id, ty) {
                panic!("attempt to bind already existing ast node type.");
            }
        }
        Ok(ast_types)
    }
}

fn substitute_constraints<'a>(
    cons: &mut Vec<Constraint<'a>>,
    subst: &SubstitutionSet<'a>,
) {
    cons.iter_mut().for_each(|c| c.substitute(&subst));
    cons.retain(|con| match con {
        Constraint::Eq{a, b, ..} => a != b,
    });
}

/// Compose two substitutions such that (a ◦ b)S = a(bS) and b := (a ◦ b).
fn compose_substs<'a>(
    a: SubstitutionSet<'a>,
    b: &mut SubstitutionSet<'a>,
    ctx: &mut InferContext<'a>,
) {
    for (_, ty) in b.subst.iter_mut() {
        ty.substitute(&a);
    }
    for (v, ty) in a.subst.into_iter() {
        if !b.subst.contains_key(&v) {
            b.subst.insert(v, ty);
        }
    }
    b.id = ctx.fresh_subst_id();
}

/// Run unify on a copy of the constraints and remove error-causing
/// constraints from constraint set
fn unify<'a>(
    cons: &mut Vec<Constraint<'a>>,
    ctx: &mut InferContext<'a>,
) -> SubstitutionSet<'a> {
    match unify_impl(cons.clone(), ctx) {
        Ok(r) => r,
        Err((r, mut culprits)) => {
            culprits.sort_unstable_by(|a, b| b.cmp(a));
            culprits.dedup();

            for i in dbg!(culprits).into_iter() {
                cons.remove(i);
            }
            r
        }
    }
}

fn unify_impl<'a>(
    cons: Vec<Constraint<'a>>,
    ctx: &mut InferContext<'a>,
) -> Result<SubstitutionSet<'a>, (SubstitutionSet<'a>, Vec<usize>)> {
    let mut r = SubstitutionSet{
        subst: IndexMap::with_capacity(cons.len()),
        id: ctx.fresh_subst_id(),
    };
    let mut errors = vec![];
    let mut error_culprits = vec![];

    let mut cons = (0..cons.len()).zip(cons.into_iter()).collect::<Vec<_>>();

    let mut i = 0;
    while i < cons.len() {
        let culprit = cons[i].0;
        match cons[i].1.clone() {
            Constraint::Eq{a, b, span, ctx: cons_ctx} => {
                match (a, b) {
                    (Type::Variable(x), Type::Variable(y)) if x == y => {
                        trace!("igoring {} = {}",
                               Type::Variable(x),
                               Type::Variable(y));
                    },

                    (Type::Variable(x), ty) | (ty, Type::Variable(x)) => {
                        if !ty.free_vars().contains(&x) {
                            let len = cons.len();
                            let mut sub = SubstitutionSet{
                                subst: indexmap!{x => ty},
                                id: ctx.fresh_subst_id(),
                            };
                            trace!("running substitution: {:?}", sub);

                            // NOTE: Not calling substitute_constraints() here
                            // since it also changes the length of the vec
                            cons[i..len]
                                .iter_mut()
                                .for_each(|c| c.1.substitute(&sub));

                            compose_substs(sub, &mut r, ctx);
                        } else {
                            let msg = span.format_err_at_pos(
                                "failed occurs check!",
                                true,
                            ).unwrap();
                            // bail!("{}", msg);
                            errors.push(msg);
                            error_culprits.push(culprit);
                        }
                    },

                    (Type::Concrete(ta, aargs), Type::Concrete(tb, bargs))
                        if ta == tb && aargs.len() == bargs.len() => {
                            if let Some(ConstraintCtx::FunCal {fun_cal: fc})
                                = cons_ctx.as_ref().map(|c| c.as_ref()) {
                                    for ((a, b), n) in aargs.into_iter()
                                        .zip(bargs.into_iter())
                                        .zip(0..) {
                                            cons.push(
                                                (culprit,
                                                 Constraint!(
                                                     eq: a, b, span,
                                                     Some(Rc::new(
                                                         ConstraintCtx::FunCalArg {
                                                             n,
                                                             fun_cal: Rc::clone(&fc),
                                                         }
                                                     )))));
                                        }
                                } else {
                                    for (a, b) in aargs.into_iter().zip(bargs.into_iter()) {
                                        cons.push(
                                            (culprit,
                                             Constraint!(
                                                 eq: a, b, span,
                                                 cons_ctx.as_ref()
                                                     .map(|ctx| Rc::clone(ctx))
                                             )));
                                    }
                                }
                        },

                    (a, b) if a == b => {
                        trace!("igoring {} = {}", a, b);
                    }

                    (a, b) => {
                        let msg = span.format_err_at_pos(
                            &format!("Type mismatch {}",
                                     cons_ctx.map(|ctx| ctx.context())
                                     .unwrap_or("".to_string())
                            ),
                            true,
                        ).unwrap();
                        // bail!("{}", msg);
                        errors.push(msg);
                        error_culprits.push(culprit);
                    },
                }
            },
        }

        i += 1;
    }

    if errors.len() > 0 {
        // bail!("{}", errors.join("\n"));
        ctx.errors.extend(errors);
        Err((r, error_culprits))
    } else {
        Ok(r)
    }
}

pub trait FormatAtPos {
    fn format_err_at_pos(&self, msg: &str, underline: bool) -> Result<String>;
    fn format_note_at_pos(&self, msg: &str, underline: bool) -> Result<String>;
}

impl<'a> FormatAtPos for Span<'a> {
    fn format_err_at_pos(&self, msg: &str, underline: bool) -> Result<String> {
        format_at_pos(
            self,
            &Paint::red("error: ").bold().to_string(),
            7,
            msg,
            self.extra,
            underline,
        )
    }

    fn format_note_at_pos(&self, msg: &str, underline: bool) -> Result<String> {
        format_at_pos(
            self,
            &Paint::yellow("note: ").bold().to_string(),
            6,
            msg,
            self.extra,
            underline,
        )
    }
}

// Foo.A for Module.A = {
//     foo(b, c) = b * c;

//     gen_constraints(this, targ, ctx, scp) = {
//         r      = mut Vec:new();
//         subscp = mut subscope(scp);
//         retty  = fresh_tvar(ctx);

//         fly_args = Vec:with_capacity(len(argnames(this)) + 1);
//         loop!(name in argnames(this)) {
//             tvar = fresh_tvar(ctx);
//             push(fty_args, coerce(tvar));
//             bind(subscp, clone(name), tvar);
//         };
//         push(fty_args, coerce(retty));
//         fty = Type:new!(Function(...fty_args));

//         push(r, Constraint:new!(ast: get_id(this), targ, span(this)));
//         push(r, Constraint:new!(eq: targ, fty, span(this)));

//         extend(r, body(this) |> gen_constraints(retty, ctx, &subscp)?)
//         ok(r)
//     };
// };

#[cfg(test)]
mod test {
    use crate::parser::File;
    use crate::ast::Span;
    use super::*;

    use rstest::*;
    use lazy_static::*;

    lazy_static! {
        static ref FILE: File = File {
            prog: "test() = 0;".to_string(),
            path: "-".to_string(),
        };
        static ref SPAN: Span<'static> = Span::new_extra(&FILE.prog, &FILE);
    }

    #[fixture]
    fn infer_ctx() -> InferContext<'static> {InferContext::new()}

    macro_rules! Constraints {
        [$(($($tt:tt)+)),*$(,)?] => (vec![$(Constraint!($($tt)+, *SPAN)),*]);
    }


    #[rstest(sub, ty, expected,
             case(indexmap!{}, Type!(Integer()), Type!(Integer())),

             case(indexmap! {
                 TypeVar(0) => Type!(Integer()),
             }, Type::Variable(TypeVar(0)), Type!(Integer())),

             case(indexmap! {
                 TypeVar(0) => Type!(Integer()),
             }, Type!(Function(TypeVar(0))), Type!(Function(Type!(Integer())))),
             ::trace
    )]
    fn type_substitute(
        sub: IndexMap<TypeVar, Type<'static>>,
        mut ty: Type<'static>,
        expected: Type<'static>,
    ) {
        ty.substitute(&SubstitutionSet{ subst: sub, id: SubstID(0) });
        assert_eq!(ty, expected);
    }

    #[rstest(constraints, expected,
             case(Constraints![
                 (eq: Type!(Integer()), Type!(Integer()))
             ], indexmap! {}),

             case(Constraints![
                 (eq: Type::Variable(TypeVar(0)), Type!(Integer()))
             ], indexmap! { TypeVar(0) => Type!(Integer())}),

             case(Constraints![
                 (eq: Type::Variable(TypeVar(0)), Type!(Integer())),
                 (eq: Type::Variable(TypeVar(1)), Type::Variable(TypeVar(0))),
             ], indexmap! {
                 TypeVar(0) => Type!(Integer()),
                 TypeVar(1) => Type!(Integer()),
             }),

             case(Constraints![
                 (eq: Type::Variable(TypeVar(0)), Type!(Integer())),
                 (eq: Type::Variable(TypeVar(0)), Type::Variable(TypeVar(1))),
             ], indexmap! {
                 TypeVar(0) => Type!(Integer()),
                 TypeVar(1) => Type!(Integer()),
             }),

             #[should_panic]
             case::occurs_check_fail(Constraints![
                 (eq: Type::Variable(TypeVar(0)), Type!(Function(TypeVar(1)))),
                 (eq: Type::Variable(TypeVar(1)), Type::Variable(TypeVar(0))),
             ], indexmap! {}),

             case(Constraints![
                 (eq: Type::Variable(TypeVar(0)), Type!(Function(TypeVar(1)))),
                 (eq: Type::Variable(TypeVar(2)), Type::Variable(TypeVar(1))),
             ], indexmap! {
                 TypeVar(0) => Type!(Function(TypeVar(1))),
                 TypeVar(2) => Type::Variable(TypeVar(1)),
             }),

             case(Constraints![
                 (eq: Type::Variable(TypeVar(1)), Type::Variable(TypeVar(2))),
                 (eq: Type::Variable(TypeVar(0)),
                  Type!(Function(Type!(Function(TypeVar(1)))))),
             ], indexmap! {
                 TypeVar(1) => Type::Variable(TypeVar(2)),
                 TypeVar(0) => Type!(Function(Type!(Function(TypeVar(2))))),
             }),

             ::trace
    )]
    fn unify_unifies<'a>(
        mut constraints: Vec<Constraint<'a>>,
        expected: IndexMap<TypeVar, Type<'a>>,
        mut infer_ctx: InferContext<'a>,
    ) {
        let SubstitutionSet{ subst: unified, ..} = unify(&mut constraints, &mut infer_ctx);

        for k in expected.keys() {
            assert_eq!((k, &unified[k]), (k, &expected[k]));
        }

        assert_eq!(infer_ctx.errors.len(), 0);
        dbg!(infer_ctx.errors);
    }
}
